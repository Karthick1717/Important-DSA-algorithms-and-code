Given an array arr of non-negative integers and an integer target, the task is to count all subsets of the array whose sum is equal to the given target.



Input: arr[] = [5, 2, 3, 10, 6, 8], target = 10
Output: 3
Explanation: The subsets {5, 2, 3}, {2, 8}, and {10} sum up to the target 10.



solution:

class Solution {

    public int perfectSum(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1; // empty subset

        for (int num : nums) {
            for (int j = target; j >= num; j--) {
                dp[j] = (dp[j] + dp[j - num]);
            }
       
        }
        return dp[target];
    }
}



Expalanation:


static int mod = 1000000007;

We use a big prime number (10^9+7) so that if counts become very large, we take remainder.

This prevents integer overflow and is also a standard practice in coding contests.

int[] dp = new int[target+1];

This creates an array where:
dp[j] = number of subsets (from elements seen so far) that have sum equal to j.

Size is target+1 because sums go from 0 to target.

dp[0] = 1;

There is exactly one way to make sum = 0:
→ by choosing the empty subset.

So we start with that as our base case.

Outer loop: for (int num : nums)

We go through each number in the input array.

For each number, we decide whether to include it in subsets or not.

Inner loop: for (int j = target; j >= num; j--)

We move backwards from target down to num.

Why backwards?
If we went forward, we’d accidentally use the same number more than once.
Backwards ensures each number is used at most once in each subset.

Update step: dp[j] = (dp[j] + dp[j - num]) % mod;

Meaning:

dp[j] already counts subsets that sum to j without using this num.

dp[j - num] counts subsets that sum to (j - num).
If we add num to each of those subsets, their sum becomes exactly j.

So total ways = old dp[j] + new ways from dp[j - num].

Return dp[target];

After processing all numbers, dp[target] contains the total count of subsets whose sum is exactly target.

Tiny Example Walkthrough

nums = [2,3,5], target = 5

Start: dp = [1,0,0,0,0,0]
(dp[0]=1 → empty set)

Take 2:

j=5: no change (dp[5] += dp[3] → 0)

j=4: no change (dp[4] += dp[2] → 0)

j=3: no change

j=2: dp[2] += dp[0] → 1
→ dp = [1,0,1,0,0,0]

Take 3:

j=5: dp[5] += dp[2] → 1 ([2,3])

j=3: dp[3] += dp[0] → 1 ([3])
→ dp = [1,0,1,1,0,1]

Take 5:

j=5: dp[5] += dp[0] → 2 ([5], [2,3])
→ dp = [1,0,1,1,0,2]

Answer: dp[5] = 2.

✅ So the final answer is 2, because subsets [5] and [2,3] sum to 5.

Would you like me to rewrite this explanation in a visual table format (like drawing dp changes after each step) so it’s easier to “see” instead of reading text?

You said:

Why backwards? If we went forward, we’d accidentally use the same number more than once. Backwards ensures each number is used **at most once** in each subset.

example please
ChatGPT said:

Perfect 👌 let’s see an example of why we must go backwards in the inner loop.

Example:

nums = [2,3], target = 5

We want subsets whose sum is exactly 5.
Possible subset: [2,3].

Case 1: Correct way (backward loop)
for (int num : nums) {
    for (int j = target; j >= num; j--) {
        dp[j] += dp[j - num];
    }
}


Step 1 (num = 2):
Start: dp = [1,0,0,0,0,0]

j=5 → no change

j=4 → no change

j=3 → no change

j=2 → dp[2] += dp[0] → 1

Result: dp = [1,0,1,0,0,0]

Step 2 (num = 3):

j=5 → dp[5] += dp[2] = 0+1 = 1 ✅ (subset [2,3])

j=3 → dp[3] += dp[0] = 0+1 = 1 ✅ (subset [3])

Final: dp = [1,0,1,1,0,1]
Answer: dp[5] = 1 → correct.

Case 2: Wrong way (forward loop)
for (int num : nums) {
    for (int j = num; j <= target; j++) {
        dp[j] += dp[j - num];
    }
}


Step 1 (num = 2):
Start: dp = [1,0,0,0,0,0]

j=2 → dp[2] += dp[0] = 1

j=3 → dp[3] += dp[1] = 0

j=4 → dp[4] += dp[2] = 1 ❌ (subset [2,2] created, but we only had one 2)

j=5 → dp[5] += dp[3] = 0

Now dp = [1,0,1,0,1,0] (WRONG, it thinks [2,2] exists).

Step 2 (num = 3):

j=3 → dp[3] += dp[0] = 1 ([3])

j=4 → dp[4] += dp[1] = 1 (still wrong)

j=5 → dp[5] += dp[2] = 0+1=1 ([2,3])

Final: dp = [1,0,1,1,1,1]
Answer: dp[5] = 1 (looks correct for this case),
but dp[4]=1 is wrong → it falsely counted [2,2].

🔑 Key Takeaway

Backward loop prevents reusing the same element multiple times.

Forward loop reuses the updated dp in the same iteration, which allows picking num more than once → like unbounded knapsack.



